# 日本語プログラミング言語「ぬこ」 [![Build Status](https://github.com/kmizu/nuko/actions/workflows/scala.yml/badge.svg?branch=main)](https://github.com/kmizu/nuko/actions)

## りーどみー

「ぬこ」はできるだけ日本語のように書くことができ、初心者にとって読みやすく理解しやすいことを目指したログラミング言語です。

変数を使った簡単なプログラムは以下のように記述することができます：

```
変数 挨拶 は　(時間 < 12) ならば "おはようございます" でなければ "こんにちは"
```

最近、プログラミング教育の必要性が叫ばれています。しかし、プログラミング言語は英語で書かれていることが多いため、英語が苦手な人にとってはハードルが高いと感じることがあります。ぬこは、日本語でプログラミングを学ぶ人々にとって、プログラミング言語の学習をより身近なものにすることを目指しています。

以下はぬこの特徴です：

* 型があるけどあまり意識しないでよい仕様
* 自然な日本語表現としてプログラムを書ける
  * 繰り返しを `{条件式} のあいだ {本体} くりかえす` のように書けます
  * 条件分岐を `{条件式} ならば　{本体} でなければ {本体}` のように書けます
  * `変数xはv` のように変数宣言ができます
* 各種データ構造が簡単に使えます
  * リスト: `リスト[1, 2, 3, 4, 5]`
  * 辞書: `辞書["apple" -> "りんご", "blue" -> "青"]`
  * 集合: `集合(1, 2, 3, 4, 5)`
* 関数型プログラミング言語としての機能を持っています
  * ですが、ぬこで関数型プログラミングを意識する必要はありません
  * 意識しないでも自然と関数型プログラミングを学べます

ぬこを使えば、日本語でお手軽に関数型プログラミングをできます。

## インストール

ぬこのインストールにはJava 17以降が必要です。

実行可能jarを[リリースページ（準備中）](https://github.com/kmizu/nuko/releases/tag/releases%2Fv0.0.1)からダウンロード可能です。適当なディレクトリに
ダウンロードしたnuko.jarを配置して、`java -jar nuko.jar`を実行してください。

## 使い方：

```
$ java -jar nuko.jar

Usage: java -jar nuko.jar (-f <fileName> | -e <expression>)
<fileName>   : read a program from <fileName> and execute it
-e <expression> : evaluate <expression>
```

次のようなプログラムを`hello.nk`という名前で保存してください：

```
表示("Hello, World!")
```

このプログラムを実行するには、`java -jar nuko.jar hello.nk`とします：

```console
$ java -jar nuko.jar hello.nk

Hello, World!
```

## 構文

### 変数宣言

```
変数 one は 1 
```

変数`one`を宣言し、その初期値を`1`とします。

### 無名ブロック

```
変数 add は (x, y) => x + y
```

変数`add`を宣言し、その初期値を`(x, y) => x + y`とします。無名ブロックは
`(引数) => 式`という形で書きます。無名ブロックは、ブロックオブジェクトを生成します。

無名ブロックの本体が複数の式に渡る場合、以下のように書けます：

```
変数 printAndAdd は (x, y) => {
  表示(x)
  表示(y)
  x + y
}
```

### ブロック定義

名前のついたブロックを定義したいこともあるでしょう。その場合は、以下のように書きます：

```
ブロック fact(n) は もし(n < 2) 1 でなければ n * fact(n - 1)
fact(0) // 1
fact(1) // 1
fact(2) // 2
fact(3) // 6
fact(4) // 24
fact(5) // 120
// The result of type inference of fact is : 整数 => 整数
```

### ブロック呼び出し

```
変数 add は (x, y) => x + y
表示(add(1, 2))
```

ブロック呼び出しは`fun(p1, p2, ..., pn)`のように書けます。`fun`の評価結果はブロックオブジェクトでなければなりません。

### リスト

```
変数 list1 は リスト(1, 2, 3, 4, 5)
表示(list1)
```

リストは`リスト(e1, e2, ...,en)`という形で書くことができます。

ぬこでは要素を区切るのために余計な記号を必要としません。たとえば、次のように要素は改行で区切ることもできます。これは他の言語にはあまり見られない特徴です：

```
変数 list2 は リスト(
  1
  2
  3
  4
  5
)
表示(list2)
変数 list3 は リスト(
              リスト(1 2 3)
              リスト(4 5 6)
              リスト(7 8 9))
```

リストの型は`List<'a>`型になります。

### 辞書

```
変数 dict1 は 辞書["apple" -> "りんご", "blue" -> "青"]
dic1 「辞書」#get "apple" // => "りんご"
dic1 「辞書」#get "blue"  // => "青"
dic1 「辞書」#get "cat"   // => null
```

辞書は

```
辞書[k1 -> v1, ..., kn ->vn]
```

のように書けます。`kn`と`vn`は式です。リストと同様に改行で要素を区切ることもできます：

```
変数 dic2 は 辞書[
  "apple" -> "りんご"
  "blue"  -> "青"
]
```

辞書の型は`Map<'k, 'v>`になります。

### 集合

集合は`集合(要素1, ..., 要素n)`のように書けます。リストと同様に改行やスペースで区切ることもできます：

```
変数 集合１ は 集合(1, 2, 3)
表示(集合1)
```

```
変数 集合２ は 集合(1 2 3) // カンマは省略できる
表示(集合2)
```

```
変数 集合３ は 集合(
  1
  2
  3
) // 改行で区切ることもできる
```

集合の型は`Set<'a>`になります。

### 代入式

代入式は宣言済みの変数に新しい値を代入します。代入には`←`または`<-`を使います。

```
変数 カウンタ は 0
カウンタ ← カウンタ + 1
表示(カウンタ) // 1 が表示される
```

### 繰り返し式

繰り返し式は、条件を満たす間、式を評価し続けます。例えば、以下のプログラムは`55`を表示します。

```
変数 合計 は 0
変数 カウンタ は 0
(カウンタ < 10) のあいだ {
  カウンタ ← カウンタ + 1
  合計 ← 合計 + カウンタ
} をくりかえす
表示(合計)
```

### 数値リテラル

ぬこではいくつかの数値リテラルがサポートされています。現時点では、`整数`、`バイト`、`小数` のリテラルがサポートされています。

### 整数

```
表示(100)
表示(200)
表示(300)
```

整数リテラルの最大値には制限がありません。

### バイト

バイトリテラルのサフィックスは`BY`です。バイトリテラルの最大値は`127`で、最小値は`-128`です。

```
表示(127BY)
表示(-127BY)
表示(100BY)
```
### 小数

```
表示(1.0)
表示(1.5)
```

ぬこの小数は10進浮動小数点数なので、直感的に扱うことができます。

2進浮動小数点数は将来的に「二進小数」のような型によってサポートする予定です。

### コメント

ぬこでは二種類のコメントを提供しています。

### ネスト可能な複数行コメント

```
1 + /* ネスト
  /* した */ コメント */ 2 // => 3
```

### 行コメント

```
1 + // コメント
    2 // => 3
```

## 型システムと型推論

ぬこは静的な型をもつプログラミング言語です。静的な型があることでプログラムのミスを早めに検出することができます。

```
ブロック 左からの畳み込み（リスト１）は (累積値) => (関数F) => {
  もし (isEmpty(リスト１)) 累積値 でなければ 左からの畳み込み(末尾(リスト１))(関数F(累積値, 先頭(リスト１)))(関数F)
}
```

### 強制型変換

場合によっては型が窮屈なこともあります。ユーザーは型変換を強制する演算子`:>`を使うことで問題を解決できます。

```
変数 s: 万物 は (100 :> 万物) // 100 は強制的に型「万物」に変換される。
```

## 組み込みブロック

ぬこはいくつかの組み込みブロックを提供しています。

### 標準入出力ブロック

- `表示: (値: 万物) => 万物`  
 
`値`を標準出力に表示します。
 
```
表示("Hello, World!")
```

- `エラー表示: (値: 万物) => 万物`  
 
`値`を標準エラー出力に表示します。

```
エラー表示("Hello, World!")
```

### 文字列操作ブロック

- `substring: (s: 文字列, begin: 整数, end: 整数) => 文章`  
 
文字列`s`の部分文字列を返します。部分文字列はインデックス`begin`からインデックス`end` - 1までを切り取った文字列です。

```
substring("FOO", 0, 1) // => "F"
```

- `at: (s:文字列, index:整数) => 文字列`  
  文字列`s`のインデックス`index`番目にある文字を返します。

```
at("BAR", 2) // => "R"
```

- `matches: (s: 文字列, regex: 文字列) => 真偽`  
  文字列`s`が正規表現`regex`にマッチした場合`true`を、そうでない場合`false`を返します。

```
変数 パターン は "[0-9]+"
matches("199", パターン) // => true
matches("a", パターン)   // => false
```

### 数値関係のブロック

- `平方根: (value:小数) => 小数`  

`値`の平方根を返します。
 
```
平方根(2.0) // => 1.4142135623730951
平方根(9.0) // => 3.0
```
  
- `整数: (値: 小数) => 整数`  
 
小数型の`値`を整数型に変換します。小数点以下は切り捨てられます。

```
整数(3.14159265359) // => 3
```

- `小数: (値: 整数) => 小数`  
 
`値`を小数型に変換します。

```
小数(10) // => 10.0
```

- `切り下げ: (値: 小数) => 整数`  
 
`値`を切り下げた値を返します。

```
切りさげ(1.5) // => 1
切り下げ(-1.5) // => -1
```

- `切り上げ: (値 :小数) => 整数`  

小数の`値`を切り上げた値を返します。
 
```
切り上げ(4.4)  // => 5
切り上げ(4.5)  // => 5
切り上げ(-4.4) // => -4
切り上げ(-4.5) // => -4
```

- `絶対値: (値: 小数) => 小数`  

`値`の絶対値を返します。
 
```
絶対値(10.5)  // => 10.5
絶対値(-10.5) // => 10.5
```

### リスト関係のブロック

- `変換: (list:List<'a>) => (fun:('a) => 'b) => List<'b>`  

ブロック`fun`を与えられたリスト`list`のすべての要素に適用した結果からなる新しいリストを返します。
 
```
変換([1 2 3])((x) => x + 1) // => [2 3 4]
変換([2 3 4]){x => x + 1}   // => [3 4 5]
 ```

- `先頭: (list: リスト<'a>) => リスト<'a>`  

`list`の最初の要素を返します。
 
```
先頭([1 2 3 4]) // => 1
```

- `末尾: (list: リスト<'a>) => リスト<'a>`  

`list`の最初の要素を除いた新しいリストを返します。
 
```
末尾([1 2 3 4]) // => [2 3 4]
```

- `構築: (value: 'a) => (list: リスト<'a>) => リスト<'a>`  

`value`と`list`を結合した新しいリストを返します。
 
```
構築(1)([2 3 4]) // => [1 2 3 4]
```

- `size: (list:List<'a>) => 整数`  
   リスト`list`の要素数を返します。
 
```
size([1 2 3 4 5]) // => 5
```

- `isEmpty: (list:List<'a>) => 真偽`
   もし`list`が空ならばtrueを、そうでなければfalseを返します。
 
```
isEmpty([])       // => true
isEmpty([1 2 3])  // => false
```

- `foldLeft: (list:List<'a>) => (acc:'b) => (fun:('b, 'a) => 'b) => 'b`  
    ブロック`fun`を開始値`acc`とリスト`list`のすべての要素に左から右に適用します。
 
```
foldLeft([1 2 3 4])(0)((x, y) => x + y)         // => 10
foldLeft([1.0 2.0 3.0 4.0])(0.0){x, y => x + y} // => 10.0
foldLeft([1.0 2.0 3.0 4.0])(1.0){x, y => x * y} // => 24.0
```

### スレッド関係のブロック

- `thread: (fun:() => 空) => 空` 
    新しいスレッドを作成し、ブロック `fun` を非同期に実行します。
    ```
    thread(() => {
      sleep(1000)
      表示("Hello from another thread.")
    })
    表示("Hello from main thread.")
    // => "Hello from main thread."
    // => "Hello from another thread."
    ```

- `sleep: (millis: 整数) => 空` 
    現在のスレッドを`millis`ミリ秒の間休眠状態にします。
    ```
    sleep(1000)
    ```

### ユーティリティブロック

- `stopwatch: (fun:() => 空) => 整数`  
   引数で渡された関数`fun`の評価にかかった時間をミリ秒単位で返します。
 
```
変数 時間 は stopwatch( => {
  sleep(1000)
  表示("1")
})
表示("#{時間} ミリ秒経過しました")
```

- `ToDo: () => 空`  
    評価されると `nuko.runtime.NotImplementedError` を投げます。

 ```
ToDo()  // => throw NotImplementedError
```

### 確認ブロック

何かの式がある値であることを確認します。確認に失敗するとその場でプログラムが終了します。これらのブロックはプログラムのバグを早めに見つけるのに役立ちます。

- `確認: (condition: 真偽) => 空`  

`condtion`が`true`かどうかを確認します。もし`false`ならプログラムはその場で終了します。

```
確認(2 == 1 + 1)  // => OK
確認(3 > 5)       // => NG。プログラムはその場で終了
 ```

- `一致を確認: (expected: Any)(actual: Any) => 空`  

`actual`が`expected`と一致することを確認します。もし一致しなければプログラムはその場で終了します。
 
```
変数 add は (x, y) => {
  x + y
}
一致を確認(5)(add(2, 3))  // => OK
一致を確認(2)(add(1, 2))  // => NG。プログラムはその場で終了
```
